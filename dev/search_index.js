var documenterSearchIndex = {"docs":
[{"location":"#PuMaS-1","page":"Home","title":"PuMaS","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"PuMaS (PharmaceUtical  Modeling And Simulation) is a suite of tools for developing, simulating, fitting, and analyzing pharmaceutical models. The purpose of this framework is to bring efficient implementations of all aspects of pharmaceutical modeling under one cohesive package. While PuMaS is still in beta, the package currently includes:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Specification of Nonlinear Mixed Effects (NLME) Models\nAutomatic parallelization of NLME simulations\nDeep control over the differential equation solvers for high efficiency\nEstimation of NLME parameters via Maximum Likelihood and Bayesian methods\nIntegrated Noncompartmental Analysis (NCA)\nSymbolic tooling for automatic calculation of system Jacobians\nInterfacing with global optimizers for more accurate parameter estimates\nSimulation and estimation diagnostics\nGlobal and local sensitivity analysis (Morris, Sobol, etc.)\nFisher Information Matrix (FIM) calculations for Optimal Design\nBioequivalence analysis and IVIVC","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Additional features are under development, with the central goal being a complete clinical trial simulation engine which combines efficiency with a standardized workflow, consistent nomenclature, and automated report generation. All of this takes place in the high level interactive Julia programming language and integrates with the other packages in the Julia ecosystem for a robust user experience.","category":"page"},{"location":"#Supporting-and-Citing-1","page":"Home","title":"Supporting and Citing","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The software in this ecosystem was developed as part of academic research. If you use PuMaS software as part of your research, teaching, or other activities, we would be grateful if you could cite our work. Our suggested citation is:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"TBD","category":"page"},{"location":"#Getting-Started:-Installation-and-First-Steps-1","page":"Home","title":"Getting Started: Installation and First Steps","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"PuMaS is distributed via JuliaPro from Julia Computing Inc. To install the package, use the following commands inside the JuliaPro REPL:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Pkg\r\nPkg.add(\"PuMaS\")","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To verify that the package has been correctly installed, you can run the command Pkg.test(\"PuMaS\") which will run an internal verification suite to ensure accuracy. When installed, use the command:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using PuMaS","category":"page"},{"location":"#","page":"Home","title":"Home","text":"to bring the functionality of PuMaS into your REPL. Once done, you are ready to start using PuMaS!","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To start understanding the package in more detail, please checkout the tutorials at the start of this manual. We highly suggest that all new users start with the Introduction to PuMaS tutorial! If you find any example where there seems to be an error, please open an issue.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For the most up to date information on using the package, please join the Slack channel.","category":"page"},{"location":"#Jupyter-Notebook-Tutorials-1","page":"Home","title":"Jupyter Notebook Tutorials","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Extra tutorials are provided with the installation of PuMaS. These tutorials are delivered in an interactive Jupyter notebook that allows you to follow along and tweak values to gain a better understanding. To install these tutorials and open the Jupyter notebooks in the browser, run the following commands:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Pkg\r\npkg\"add https://github.com/UMCTM/PuMaSTutorials.jl\"\r\nusing PuMaSTutorials\r\nPuMaSTutorials.open_notebooks()","category":"page"},{"location":"#Annotated-Table-Of-Contents-1","page":"Home","title":"Annotated Table Of Contents","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Below is an annotated table of contents with summaries to help guide you to the appropriate page. The materials shown here are links to the same materials in the sidebar. Additionally, you may use the search bar provided on the left to directly find the manual pages with the appropriate terms.","category":"page"},{"location":"#Tutorials-1","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"These tutorials give an \"example first\" approach to learning PuMaS and establish the standardized nomenclature for the package. Additionally, ways of interfacing with the rest of the Julia ecosystem for visualization and statistics are demonstrated. Thus we highly recommend new users check out these tutorials before continuing into the manual. More tutorials can be found in the PuMaSTutorials.jl repository.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\r\n    \"tutorials/introduction.md\",\r\n]","category":"page"},{"location":"#Basics-1","page":"Home","title":"Basics","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The basics are the core principles of using PuMaS. An overview introduces the user to the basic design tenants, and manual pages proceed to give details on the central functions and types used throughout PuMaS.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\r\n    \"basics/overview.md\",\r\n    \"basics/models.md\",\r\n    \"basics/doses_subjects_populations.md\",\r\n    \"basics/simulation.md\",\r\n    \"basics/estimation.md\",\r\n    \"basics/nca.md\",\r\n    \"basics/faq.md\",\r\n]","category":"page"},{"location":"#Model-Components-1","page":"Home","title":"Model Components","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This section of the documentation goes into more detail on the model components, specifying the possible domain types, dosage control parameters (DCP), and the various differential equation types for specifying problems with analytical solutions and alternative differential equations such as delay differential equations (DDEs), stochastic differential equations (SDEs), etc.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\r\n    \"model_components/domains.md\",\r\n    \"model_components/dosing_control.md\",\r\n    \"model_components/dynamical_types.md\",\r\n]","category":"page"},{"location":"#Analysis-1","page":"Home","title":"Analysis","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This section of the documentation defines the analysis tooling. Essential tools such as diagnostics, plotting, report generation, and sensitivity analysis are discussed in detail in this portion.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\r\n    \"analysis/diagnostics.md\",\r\n    \"analysis/sensitivity.md\",\r\n]","category":"page"},{"location":"#PuMaS-Development-Team-1","page":"Home","title":"PuMaS Development Team","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The PuMaS team is supported by the University of Maryland, Baltimore Center for Translational Medicine (CTM). Vijay Ivaturi is the project lead and Chris Rackauckas is the lead developer. For information on developing and supporting PuMaS, please consult Vijay Ivaturi.","category":"page"},{"location":"tutorials/introduction/#Introduction-to-PuMaS-1","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"","category":"section"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"This is an introduction to PuMaS, a software for pharmaceutical modeling and simulation.","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"The basic workflow of PuMaS is:","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"Build a model.\nDefine subjects or populations to simulate or estimate.\nAnalyze the results with post-processing and plots.","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"We will show how to build a multiple-response PK/PD model via the @model macro, define a subject with multiple doses, and analyze the results of the simulation. This tutorial is made to be a broad overview of the workflow and more in-depth treatment of each section can be found in the subsequent tutorials and documentation.","category":"page"},{"location":"tutorials/introduction/#Working-Example-1","page":"Introduction to PuMaS","title":"Working Example","text":"","category":"section"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"Let's start by showing a complete simulation code, and then break down how it works.","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"using PuMaS, LinearAlgebra\r\n\r\nmodel = @model begin\r\n\r\n    @param begin\r\n      θ ∈ VectorDomain(12)\r\n    end\r\n\r\n    @random begin\r\n      η ~ MvNormal(Matrix{Float64}(I, 11, 11))\r\n    end\r\n\r\n    @pre begin\r\n        Ka     = θ[1]\r\n        CL      = θ[2]*exp(η[1])\r\n        Vc      = θ[3]*exp(η[2])\r\n        Q       = θ[4]*exp(η[3])\r\n        Vp      = θ[5]*exp(η[4])\r\n        Kin     = θ[6]*exp(η[5])\r\n        Kout    = θ[7]*exp(η[6])\r\n        IC50    = θ[8]*exp(η[7])\r\n        IMAX    = θ[9]*exp(η[8])\r\n        γ       = θ[10]*exp(η[9])\r\n        Vmax    = θ[11]*exp(η[10])\r\n        Km      = θ[12]*exp(η[11])\r\n    end\r\n\r\n    @init begin\r\n        Resp = Kin/Kout\r\n    end\r\n\r\n    @dynamics begin\r\n        Depot'    = -Ka1*Depot\r\n        Cent'   =  Ka1*Depot - (CL+Vmax/(Km+(Cent/Vc))+Q)*(Cent/Vc)  + Q*(Periph/Vp)\r\n        Periph' =  Q*(Cent/Vc)  - Q*(Periph/Vp)\r\n        Resp'   =  Kin*(1-(IMAX*(Cent/Vc)^γ/(IC50^γ+(Cent/Vc)^γ)))  - Kout*Resp\r\n    end\r\n\r\n    @derived begin\r\n        depot    = Depot\r\n        cp     = Cent / Vc\r\n        periph = Periph\r\n        resp   = Resp\r\n    end\r\nend\r\n\r\nregimen = DosageRegimen([15,15,15,15], time=[0,4,8,12])\r\nsubject = Subject(id=1,evs=regimen)\r\n\r\np = (θ = [\r\n          1, # Ka  Absorption rate constant 1 (1/time)\r\n          1, # CL   Clearance (volume/time)\r\n          20, # Vc   Central volume (volume)\r\n          2, # Q    Inter-compartmental clearance (volume/time)\r\n          10, # Vp   Peripheral volume of distribution (volume)\r\n          10, # Kin  Response in rate constant (1/time)\r\n          2, # Kout Response out rate constant (1/time)\r\n          2, # IC50 Concentration for 50% of max inhibition (mass/volume)\r\n          1, # IMAX Maximum inhibition\r\n          1, # γ    Emax model sigmoidicity\r\n          0, # Vmax Maximum reaction velocity (mass/time)\r\n          2  # Km   Michaelis constant (mass/volume)\r\n          ],) # single element `NamedTuple`s end with a comma\r\n\r\nsim = simobs(model, subject, p)\r\nplot(sim)","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"(Image: Plot sim)","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"In this code, we defined a nonlinear mixed effects model by describing the parameters, the random effects, the dynamical model, and the derived (result) values. Then we generated a subject who receives doses of 15mg every 4 hours, specified parameter values, simulated the model, and generated a plot of the results. Now let's walk through this process!","category":"page"},{"location":"tutorials/introduction/#Using-the-Model-Macro-1","page":"Introduction to PuMaS","title":"Using the Model Macro","text":"","category":"section"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"First we define the model. The simplest way to do is via the @model DSL. Inside of this block we have a few subsections. The first of which is @param. In here we define what kind of parameters we have. For this model we will define a vector parameter θ of size 12:","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"@param begin\r\n  θ ∈ VectorDomain(12)\r\nend","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"Next we define our random effects. The random effects are defined by a distribution from Distributions.jl. For more information on defining distributions, please see the Distributions.jl documentation. For this tutorial, we wish to have a multivariate normal of 11 uncorrelated random effects, so we utilize the syntax:","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"using LinearAlgebra\r\n@random begin\r\n  η ~ MvNormal(Matrix{Float64}(I, 11, 11))\r\nend","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"Notice that here we imported I from LinearAlgebra and said that our Normal distribution's covariance is said I, the identity matrix.","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"Now we define our pre-processing step in @pre. This is where we choose how the parameters, random effects, and the covariates collate. We define the values and give them a name as follows:","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"@pre begin\r\n    Ka1     = θ[1]\r\n    CL      = θ[2]*exp(η[1])\r\n    Vc      = θ[3]*exp(η[2])\r\n    Q       = θ[4]*exp(η[3])\r\n    Vp      = θ[5]*exp(η[4])\r\n    Kin     = θ[6]*exp(η[5])\r\n    Kout    = θ[7]*exp(η[6])\r\n    IC50    = θ[8]*exp(η[7])\r\n    IMAX    = θ[9]*exp(η[8])\r\n    γ       = θ[10]*exp(η[9])\r\n    Vmax    = θ[11]*exp(η[10])\r\n    Km      = θ[12]*exp(η[11])\r\nend","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"Next we define the @init block which gives the initial values for our differential equations. Any variable not mentioned in this block is assumed to have a zero for its starting value. We wish to only set the starting value for Resp, and thus we use:","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"@init begin\r\n    Resp = Kin/Kout\r\nend","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"Now we define our dynamics. We do this via the @dynamics block. Differential variables are declared by having a line defining their derivative. For our model, we use:","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"@dynamics begin\r\n    Depot'    = -Ka1*Depot\r\n    Cent'   =  Ka1*Depot - (CL+Vmax/(Km+(Cent/Vc))+Q)*(Cent/Vc)  + Q*(Periph/Vp)\r\n    Periph' =  Q*(Cent/Vc)  - Q*(Periph/Vp)\r\n    Resp'   =  Kin*(1-(IMAX*(Cent/Vc)^γ/(IC50^γ+(Cent/Vc)^γ)))  - Kout*Resp\r\nend","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"Lastly we utilize the @derived macro to define our post-processing. We can output values using the following:","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"@derived begin\r\n    depot    = Depot\r\n    cp     = Cent / θ[3]\r\n    periph = Periph\r\n    resp   = Resp\r\nend","category":"page"},{"location":"tutorials/introduction/#Building-a-Subject-1","page":"Introduction to PuMaS","title":"Building a Subject","text":"","category":"section"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"Now let's build a subject to simulate the model with. A subject defines three components:","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"The dosage regimen\nThe covariates of the individual\nObservations associated with the individual.","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"Our model did not make use of covariates so we will ignore (2) for now, and (3) is only necessary for fitting parameters to data which will not be covered in this tutorial. Thus our subject will be defined simply by its dosage regimen.","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"To do this, we use the DosageRegimen constructor. It uses terms from the NMTRAN format to specify its dose schedule. The first value is always the dosing amount. Then there are optional arguments, the most important of which is time which specifies the time that the dosing occurs. For example,","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"DosageRegimen(15, time=0)","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"is a dosage regimen which simply does a single dose at time t=0 of amount 15. If we use arrays, then the dosage regimen will be the grouping of the values. For example, let's define a dose of amount 15 at times t=0,4,8, and 12:","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"regimen = DosageRegimen([15,15,15,15], time=[0,4,8,12])","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"Let's define our subject to have id=1 and this multiple dosing regimen:","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"subject = Subject(id=1,evs=regimen)","category":"page"},{"location":"tutorials/introduction/#Running-a-Simulation-1","page":"Introduction to PuMaS","title":"Running a Simulation","text":"","category":"section"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"The main function for running a simulation is simobs. simobs on a population simulates all of the population (in parallel), while simobs on a subject simulates just that subject. If we wish to change the parameters from the initialized values, then we pass them in. Let's simulate subject 1 with a set of chosen parameters:","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"param = (θ = [\r\n          1, # Ka  Absorption rate constant 1 (1/time)\r\n          1, # CL   Clearance (volume/time)\r\n          20, # Vc   Central volume (volume)\r\n          2, # Q    Inter-compartmental clearance (volume/time)\r\n          10, # Vp   Peripheral volume of distribution (volume)\r\n          10, # Kin  Response in rate constant (1/time)\r\n          2, # Kout Response out rate constant (1/time)\r\n          2, # IC50 Concentration for 50% of max inhibition (mass/volume)\r\n          1, # IMAX Maximum inhibition\r\n          1, # γ    Emax model sigmoidicity\r\n          0, # Vmax Maximum reaction velocity (mass/time)\r\n          2  # Km   Michaelis constant (mass/volume)\r\n          ],)\r\n\r\nsim = simobs(model, subject, param)","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"We can then plot the simulated observations by using the plot command:","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"using Plots\r\nplot(sim)","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"(Image: show plot)","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"Note that we can use the attributes from Plots.jl to further modify the plot. For example,","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"plot(sim,\r\n     color=2,thickness_scaling=1.5,\r\n     legend=false, lw=2)","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"(Image: show plot)","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"Notice that in our model we said that there was a single parameter θ so our input parameter is a named tuple with just the name θ. When we only give the parameters, the random effects are automatically sampled from their distributions. If we wish to prescribe a value for the random effects, we pass initial values similarly:","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"randeffs = (η = rand(11),)\r\nsim = simobs(model, subject, param, randeffs)\r\nplot(sim)","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"(Image: show plot)","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"If a population simulation is required with no random effects, then the values of the η's can be set to zero that will result in a simulation only at the mean level:","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"randeffs = (η = zeros(11),)\r\nsim = simobs(model, subject, fixeffs, randeffs)\r\nplot(sim)","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"The points which are saved are by default at once every hour until one day after the last event. If you wish to change the saving time points, pass the keyword argument obstimes. For example, let's save at every 0.1 hours and run the simulation for 19 hours:","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"sim = simobs(model, subject, param, randeffs, obstimes = 0:0.1:19)\r\nplot(sim)","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"(Image: show plot)","category":"page"},{"location":"tutorials/introduction/#Handling-the-SimulatedObservations-1","page":"Introduction to PuMaS","title":"Handling the SimulatedObservations","text":"","category":"section"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"The resulting SimulatedObservations type has two fields. sim.times is an array of time points for which the data was saved. sim.derived is the result of the derived variables. From there, the derived variables are accessed by name. For example,","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"sim[:cp]","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"is the array of cp values at the associated time points. We can turn this into a DataFrame via using the DataFrame command:","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"DataFrame(sim)","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"From there, any Julia tools can be used to analyze these arrays and DataFrames. For example, if we wish the plot the result of depot over time, we'd use the following:","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"plot(sim.times,sim[:depot])","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"Using these commands, a Julia program can be written to post-process the program however you like!","category":"page"},{"location":"tutorials/introduction/#Conclusion-1","page":"Introduction to PuMaS","title":"Conclusion","text":"","category":"section"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"This tutorial covered basic workflow for how to build a model and simulate results from it. The subsequent tutorials will go into more detail in the components, such as:","category":"page"},{"location":"tutorials/introduction/#","page":"Introduction to PuMaS","title":"Introduction to PuMaS","text":"More detailed treatment of specifying populations, dosage regimens, and covariates.\nReading in dosage regimens and observations from NMTRAN data.","category":"page"},{"location":"basics/overview/#Overview-of-PuMaS-1","page":"Overview of PuMaS","title":"Overview of PuMaS","text":"","category":"section"},{"location":"basics/overview/#","page":"Overview of PuMaS","title":"Overview of PuMaS","text":"PuMaS is a collection of a modules that facilitate workflows related to data analysis in the pre-clinical and clinical development stages of drug development. This document provides a general overview of each of these workflows.","category":"page"},{"location":"basics/overview/#The-PuMaS-NLME-Workflow-1","page":"Overview of PuMaS","title":"The PuMaS NLME Workflow","text":"","category":"section"},{"location":"basics/overview/#","page":"Overview of PuMaS","title":"Overview of PuMaS","text":"The core PuMaS NLME workflow is:","category":"page"},{"location":"basics/overview/#","page":"Overview of PuMaS","title":"Overview of PuMaS","text":"Define a PuMaSModel. This model defines the structure of the NLME model, but not necessarily the values.\nDefine a Subject and Population. These structure specify the dosage regimens of the patients, their covariates, and possible observation data to fit against. This can be done programmatically or by reading in tabular input data.\nDefine a param NamedTuple for the parameters describing the structure of the PuMaSModel. For simulation, these are the parameter values to simulate with. For estimation, these are the initial conditions.\nCall the model API functions (simobs and fit) to perform the simulations and estimation. Both functions act on the pieces defined before.","category":"page"},{"location":"basics/overview/#","page":"Overview of PuMaS","title":"Overview of PuMaS","text":"This workflow directly integrates with usage of the Julia language. For example, one may define Julia functions and use these functions within the definition of a PuMaSModel. Additionally, one may write loops that defines Subjects or new random params and use these in simulations via simobs. Thus PuMaS gives the core tools for handling NLME models but is a lean system that allows the user to seamlessly utilize the larger Julia ecosystem to solve their problem.","category":"page"},{"location":"basics/overview/#","page":"Overview of PuMaS","title":"Overview of PuMaS","text":"After fits and simulations are performed, the returned objects have smart defaults that allow for inspection. Each returned object has a DataFrame overload so that DataFrame(ret) displays the simulation or estimation as tabular data. Additionally, each returned object has a plot overload so that","category":"page"},{"location":"basics/overview/#","page":"Overview of PuMaS","title":"Overview of PuMaS","text":"using Plots\r\nplot(ret)","category":"page"},{"location":"basics/overview/#","page":"Overview of PuMaS","title":"Overview of PuMaS","text":"gives a standardized plot (with options) of the simulation or estimation. All of the internal values are accessible and the fields are documented within the manual.","category":"page"},{"location":"basics/overview/#The-PuMaS-NCA-Module-Workflow-1","page":"Overview of PuMaS","title":"The PuMaS NCA Module Workflow","text":"","category":"section"},{"location":"basics/overview/#","page":"Overview of PuMaS","title":"Overview of PuMaS","text":"The NCA submodule works by:","category":"page"},{"location":"basics/overview/#","page":"Overview of PuMaS","title":"Overview of PuMaS","text":"Defining an NCASubject or NCAPopulation, either programmatically or by reading tabular data in the PuMaSNCADF format.\nRunning NCA functions on the subject or population, such as NCA.auc, or generating a full NCA.report.","category":"page"},{"location":"basics/overview/#","page":"Overview of PuMaS","title":"Overview of PuMaS","text":"Each of the NCA data objects have smart defaults that allow for inspection. Each of them has a plot overload so that:","category":"page"},{"location":"basics/overview/#","page":"Overview of PuMaS","title":"Overview of PuMaS","text":"using Plots\r\nplot(nca)","category":"page"},{"location":"basics/overview/#","page":"Overview of PuMaS","title":"Overview of PuMaS","text":"gives a standardized plot (with options) of the NCA data.","category":"page"},{"location":"basics/models/#Defining-NLME-Models-1","page":"Defining NLME Models","title":"Defining NLME Models","text":"","category":"section"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Nonlinear Mixed Effects (NLME) models are central to pharmacometric modeling. A model is the structure which includes the dynamical equations, the structure of the parameters (the names, domains, and constraints), and the observables. This page documents the two interfaces for defining a NLME model:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The @model Domain-Specific Language (DSL) is for simplified definitions of NLME models with standard naming assumptions.\nThe function-based interface is for defining NLME models via Julia functions, allowing for full flexibility and efficiency.","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"We recommend that all users start with the @model DSL, and computationally-inclined pharmacometricians who are comfortable with more programmatic development (or those who need the enlarged feature-set) may wish to utilize the function-based interface. Both interface with the proceeding simulation and estimation tooling in the same manner.","category":"page"},{"location":"basics/models/#Quick-Note-on-Probability-Distributions-1","page":"Defining NLME Models","title":"Quick Note on Probability Distributions","text":"","category":"section"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Many of the NLME model definition portions require the specification of probability distributions. The distributions in PuMaS are defined by the Distributions.jl library. All of the Distributions.jl Distribution types are able to be used throughout the PuMaS model definitions. Multivariate domains defines values which are vectors while univariate domains define values which are scalars. For the full documentation of the Distribution types, please see the Distributions.jl documentation","category":"page"},{"location":"basics/models/#The-@model-DSL-1","page":"Defining NLME Models","title":"The @model DSL","text":"","category":"section"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The @model DSL allows for simplified NLME definitions. This interface can also be used to define simpler linear and probability distribution models without the mixed effects. The components of a model (in order) are as follows:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"@param defines the fixed effects and other parameters of the model, along with the domains and constraints on the parameters (for estimation).\n@random (optional) defines the random effects via probability distributions on the parameters.\n@covariates (optional) defines the covariates of the model.\n@pre defines the pre-processing collation between the parameters, random effects, and covariates for the definition of the dynamical parameters.\n@vars (optional) defines aliases that can be used in the proceeding blocks.\n@init (optional) defines the initial conditions for the dynamical model.\n@dynamics (optional) defines the dynamical model, either by its differential equation or its analytical solution.\n@derived defines the derived observables from the dynamical model's solution, including the error distributions.\n@observed (optional) defines post-processing on the observables sampled from the error distributions.","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"All of these blocks allow the use of Julia functions defined outside of the macro.","category":"page"},{"location":"basics/models/#@param:-Parameters-1","page":"Defining NLME Models","title":"@param: Parameters","text":"","category":"section"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"This block defines the structure of the parameters within the model. Parameters are defined by an in (or ∈, written via \\in) statement specifying the Domain type that the parameter  resides in. For example, to specify θ as a real scalar, one would write:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"θ in RealDomain()","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"θ ∈ RealDomain()","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Many of these domains allow specifying bounds, for example, we can specify θ as a scalar between 0.0 and 1.0 via:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"θ ∈ RealDomain(lower=0.0, upper=1.0)","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"For the full specifications of the domain types, please the the Domains page. Additionally, parameters can be defined via a probability distributions, in which case the values are defined via ~. For example, we can say that θ comes from a standard normal distribution via:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"θ ~ Normal(0,1)","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Implicitly, the domain of θ is the support of the probability distributions. Thus for this example, the domain of θ is the same as RealDomain(). However, if the value of θ is not specified in the parameter list during simulation, θ will automatically be sampled from this distribution. Additionally, this probability distribution can be thought of as the prior distribution on θ and is utilized in Bayesian estimation routines.","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The parameters block is a list of parameter domain definitions, for example:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"@param begin\r\n    θ ∈ VectorDomain(3, lower=[0.0,0.0,0.0], upper=[20.0,20.0,20.0])\r\n    Ω ∈ PSDDomain(2)\r\n    Σ ∈ ConstDomain(0.1)\r\nend","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Note that this block is for the structure and not the values of the parameters. The values are defined when invoking simulation or estimation so that they can more easily be modified.","category":"page"},{"location":"basics/models/#@random:-Random-Effects-1","page":"Defining NLME Models","title":"@random: Random Effects","text":"","category":"section"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"This block defines the structure of the random effect sampling process. These structures are given by ~ statements to probability distributions which may be defined by parameters. For example, if Ω is a positive-definite matrix, we can specify that η is defined as a sample from a multivariate normal distribution with covariance matrix Ω via the statement:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"η ~ MVNormal(Ω)","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The @random block is defined by a list of such statements, like:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"@random begin\r\n   η ~ MVNormal(Ω)\r\n   κ ~ MVNormal(Π)\r\nend","category":"page"},{"location":"basics/models/#@covariates:-Covariates-1","page":"Defining NLME Models","title":"@covariates: Covariates","text":"","category":"section"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The @covariates block defines the names of the covariates. This is a simply a list of names, such as:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"@covariates wt sex height","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"or","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"@covariates begin\r\n   wt\r\n   sex\r\n   height\r\nend","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Covariates in the model match the structures they inherit from the data defined in the Subject.","category":"page"},{"location":"basics/models/#@pre:-Pre-Processing-1","page":"Defining NLME Models","title":"@pre: Pre-Processing","text":"","category":"section"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The @pre block defines the pre-processing collation for the definition of the dynamical parameters from the fixed and random effects. These values are specified by equality (=) statements. For example, one may specify that the parameter Ka is defined by the first value of θ and the first value of η, we can write the command:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Ka = θ[1] * exp(η[1])","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Standard Julia syntax can be used within this block, any externally defined Julia functions can be used in this block, and the resulting variables can be any Julia type. One consequence of allowing these values to be any Julia type is that the pre-processed variables can be Julia functions. For example, we can define Ka as a time-dependent function by using Julia's anonymous function syntax:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Ka = t -> t*θ[1]","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"@pre is defined by a list of such equality statements, for example:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"@pre begin\r\n    Ka     = θ[1]\r\n    CL      = θ[2]*exp(η[1])\r\n    Vc      = t -> t*θ[3]*exp(η[2])\r\nend","category":"page"},{"location":"basics/models/#Dosing-Control-Parameters-1","page":"Defining NLME Models","title":"Dosing Control Parameters","text":"","category":"section"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Special parameters, such as lag, are used to control the internal event handling (dosing) system. For more information on these parameters, see the Dosing Control Parameters page.","category":"page"},{"location":"basics/models/#@vars:-Variable-Aliases-1","page":"Defining NLME Models","title":"@vars: Variable Aliases","text":"","category":"section"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The @vars block defines aliases which can be used in the proceeding blocks. In the @init and @dynamics blocks the statement is interpreted to take place at the current solver time, while in the @derived and @observed the values alias the time series along the solution. An alias is defined by an equality (=) statement. For example, to define conc as an alias for the dynamical variable Central divided by the parameter V, we would write the equation:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"@vars begin\r\n   conc = Central / V\r\nend","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Note that the variable t for time can be utilized within these expressions. Inside the @init and @dynamics blocks it stands for the solver time, while in the @derived and @observed blocks it stands for the current time in the time series. For example,","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"@vars begin\r\n   conc_t = conc / t\r\nend","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"is the value of conc divided by t.","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The @vars block is defined by a list of such equality statements, such as:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"@vars begin\r\n    conc   = Central / V\r\n    conc_t = conc / t\r\nend","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Note that the special value := can be used to define intermediate statements that will not be carried outside of the block.","category":"page"},{"location":"basics/models/#@init:-Initial-Conditions-1","page":"Defining NLME Models","title":"@init: Initial Conditions","text":"","category":"section"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"This block defines the initial conditions of the dynamical model in terms of the parameters, random effects, and pre-processed variables. It is defined by a series of equality (=) statements. For example, to set the initial condition of the Response dynamical variable to be the value of the 5th term of the parameter θ, we would use the syntax:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Response = θ[5]","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The block is then given by a sequence of such statements, such as:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"@init begin\r\n   Response1 = θ[5]\r\n   Response2 = Kin/Kout\r\nend","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"where Kin and Kout were defined earlier in the @pre block.","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Any variable omitted from this block is given the default initial condition of 0. If the block is omitted, then all dynamical variables are initialized at 0.","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Note that the special value := can be used to define intermediate statements that will not be carried outside of the block.","category":"page"},{"location":"basics/models/#@dynamics:-The-Dynamical-Model-1","page":"Defining NLME Models","title":"@dynamics: The Dynamical Model","text":"","category":"section"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The @dynamics block defines the nonlinear function from the parameters to the derived variables via a dynamical (differential equation) model. It can currently be specified either by an analytical solution type or via an ordinary differential equation (ODE) (for more types of differential equations, please see the function-based interface).","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The analytical solutions are defined in the dynamical types page and can be invoked via the name. For example,","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"@dynamics OneCompartmentModel","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"defines the dynamical model as the OneCompartmentModel.","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"For a system of ODEs, the dynamical variables are defined by their derivative expression. A derivative expression is given by a variable's derivative (specified by ') and an equality (=). For example, the following defines the value Depot by it's ODE:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Depot' = -Ka*Depot","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"where Ka was defined in the @pre block. Variable aliases defined in the @vars are accessible in this block. Additionally, the variable t is reserved for the solver time. For example, if Ka(t) was defined as a function in the @pre block, then the value of Ka at solver time can be utilized in the derivative expression via:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Depot' = -Ka(t)*Depot","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"This is utilized for handling constructs such as time-varying covariates.","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Note that any Julia function defined outside of the @model block can be invoked in the @dynamics block.","category":"page"},{"location":"basics/models/#@derived:-Derived-Observables-1","page":"Defining NLME Models","title":"@derived: Derived Observables","text":"","category":"section"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The @derived block defines the derived observables of the NLME model. They can be defined by any combination of the parameters, random effects, covariates, preprocessed variables, dynamical variables, and aliases. In this block, the value t is the time series which matches the array given in subject.time. The dynamical variables are an array which matches t in size, where var[i] is the value of the dynamical variable at time t[i]. Any aliases of a dynamical variable are also a time series.","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Observables can either be defined by equality statements = or by a distribution with ~. For example, the equality statement","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"conc = @. Central / V","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"defines an array conc to be output from the model. Notice that we used Julia's broadcast syntax (@.) for specifying that every value of Central is to be divided by V. Note that any standard Julia syntax (and externally defined functions) are allowed in this block.","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Error models are defined by ~ statements to probability distributions. For example, the following defines a time series of Normal distributions centered around the value of conc with a variance dependent on conc and ϵ:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"@derived begin\r\n   dv ~ @. Normal(conc,conc*ϵ)\r\nend","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The likelihood of these distributions are utilized in the maximum likelihood and Bayesian estimation routines. Additionally, values in the @observed block are sampled from these error models.","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The @derived block is defined by a list of these expressions, for example:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"@derived begin\r\n   conc = @. Central / V\r\n   dv ~ @. Normal(conc,conc*ϵ)\r\nend","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Note that the special value := can be used to define intermediate statements that will not be carried outside of the block.","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"As a convenience, tie-ins with the included Noncompartmental Analysis (NCA) suite are given with via the @nca macro. For example, we can perform an NCA analysis via:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"@derived begin\r\n   conc = @. Central / V\r\n   dv ~ @. Normal(conc,conc*ϵ)\r\n   nca := @nca conc\r\nend","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"to build an NCASubject using the time series given by the derived or dynamical variable conc. Once defined, the functionality of the NCA module can be used to define derived variables via NCA diagnostics, for example:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"@derived begin\r\n   conc = @. Central / V\r\n   dv ~ @. Normal(conc,conc*ϵ)\r\n   nca := @nca conc\r\n   auc =  NCA.auc(nca)\r\n   thalf =  NCA.thalf(nca)\r\n   cmax = NCA.cmax(nca)\r\nend","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Notice that the @derived block can mix values of different types (such as arrays and scalars) in the output.  ","category":"page"},{"location":"basics/models/#@observed:-Sampled-Observations-1","page":"Defining NLME Models","title":"@observed: Sampled Observations","text":"","category":"section"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The @observed block allows one to define output variables based on the sampled values from the error model. These are given by equality statements (=) which can utilize the parameters, random effects, covariates, dynamical variables, and any sampled derived variables. For example, if we had defined:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"@derived begin\r\n   dv ~ @. Normal(conc,conc*ϵ)\r\nend","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"then we can add the simulated AUC of the concentration with the error model's stochasticity (the dv values of one simulation) by utilizing the NCA features from within the @observed block as follows:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"@observed begin\r\n   nca := @nca dv\r\n   sampled_auc = NCA.auc(nca)\r\nend","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"If no @observed block is specified, then the results of a simulation will simply be the derived values and the samples from the error models.","category":"page"},{"location":"basics/models/#The-PuMaSModel-Function-Based-Interface-1","page":"Defining NLME Models","title":"The PuMaSModel Function-Based Interface","text":"","category":"section"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The PuMaSModel function-based interface for defining an NLME model is the most expressive mechanism for using PuMaS and directly utilizes Julia types and functions. In fact, under the hood the @model DSL works by building an expression for the PuMaSModel interface! A PuMaSModel has the constructor:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"PuMaSModel(paramset,random,pre,init,prob,derived,observed=(col,sol,obstimes,samples,subject)->samples)","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Notice that the observed function is optional. This section describes the API of the functions which make up the PuMaSModel type. The structure closely follows that of the @model macro but is more directly Julia syntax.","category":"page"},{"location":"basics/models/#The-paramset-ParamSet-1","page":"Defining NLME Models","title":"The paramset ParamSet","text":"","category":"section"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The value paramset is a ParamSet object which takes in a named tuple of Domain types. These Domain types are defined on the Domains page. For example, the following is a value ParamSet construction:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"paramset = ParamSet((θ = VectorDomain(4, lower=zeros(4)), # parameters\r\n              Ω = PSDDomain(2),\r\n              Σ = RealDomain(lower=0.0),\r\n              a = ConstDomain(0.2)))","category":"page"},{"location":"basics/models/#The-random-Function-1","page":"Defining NLME Models","title":"The random Function","text":"","category":"section"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The random(param) function is a function on the parameters. It takes in the values from the param input named tuple and outputs a ParamSet for the random effects. For example:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"function random(p)\r\n    ParamSet((η=MvNormal(p.Ω),))\r\nend","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"is a valid random function.","category":"page"},{"location":"basics/models/#The-pre-Function-1","page":"Defining NLME Models","title":"The pre Function","text":"","category":"section"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The pre function takes in the param named tuple, the sampled randeffs named tuple, and the subject data and defines the named tuple of the collated preprocessed dynamical parameters. For example, the following is a valid definition of the pre function:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"function pre(param,randeffs,subject)\r\n    (Σ  = param.Σ,\r\n    Ka = param.θ[1],  # pre\r\n    CL = param.θ[2] * ((subject.covariates.wt/70)^0.75) *\r\n         (param.θ[4]^subject.covariates.sex) * exp(randeffs.η[1]),\r\n    V  = param.θ[3] * exp(randeffs.η[2]))\r\nend","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The output can be any valid Julia type. Notice that the covariates are specified via the subject.covariates field.","category":"page"},{"location":"basics/models/#Dosing-Control-Parameters-2","page":"Defining NLME Models","title":"Dosing Control Parameters","text":"","category":"section"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Special parameters in the return of the pre function, such as lag, are used to control the internal event handling (dosing) system. For more information on these parameters, see the Dosing Control Parameters page.","category":"page"},{"location":"basics/models/#The-init-Function-1","page":"Defining NLME Models","title":"The init Function","text":"","category":"section"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The init function defines the initial conditions of the dynamical variables from the collated preprocessed values col and the initial time point t0. Note that this follows the DifferentialEquations.jl convention, in that the initial value type defines the type for the state used in the evolution equation.","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"For example, the following defines the initial condition to be a vector of two zeros:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"function init(col,t0)\r\n   [0.0,0.0]\r\nend","category":"page"},{"location":"basics/models/#The-prob-DEProblem-1","page":"Defining NLME Models","title":"The prob DEProblem","text":"","category":"section"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The prob is a DEProblem defined by DifferentialEquations.jl. It can be any DEProblem, and the choice of DEProblem specifies the type of dynamical model. For example, if prob is an SDEProblem, then the NLME will be defined via a stochastic differential equation, and if prob is a DDEProblem, then the NLME will be defined via a delay differential equation. For details on defining a DEProblem, please consult the DifferentialEquations.jl documentation.","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Note that the timespan, initial condition, and parameters are sentinels that will be overridden in the simulation pipeline. Thus, for example, we can define prob as an ODEProblem omitting these values as follows:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"function onecompartment_f(du,u,p,t)\r\n    du[1] = -p.Ka*u[1]\r\n    du[2] =  p.Ka*u[1] - (p.CL/p.V)*u[2]\r\nend\r\nprob = ODEProblem(onecompartment_f,nothing,nothing,nothing)","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Notice that the parameters of the differential equation p is the result value pre.","category":"page"},{"location":"basics/models/#The-derived-Function-1","page":"Defining NLME Models","title":"The derived Function","text":"","category":"section"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The derived function takes in the collated preprocessed values col, the DESolution to the differential equation sol, the obstimes set during the simulation and estimation, and the full subject data. The output can be any Julia type on which map(f,x) is defined (the map is utilized for the subsequent sampling of the error models). For example, the following is a valid derived function which outputs a named tuple:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"function derived(col,sol,obstimes,subject)\r\n    central = sol(obstimes;idxs=2)\r\n    conc = @. central / col.V\r\n    dv = @. Normal(conc, conc*col.Σ)\r\n    (dv=dv,)\r\nend","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Note that probability distributions in the output have a special meaning in maximum likelihood and Bayesian estimation, and are automatically sampled to become observation values during simulation.","category":"page"},{"location":"basics/models/#The-observed-Function-1","page":"Defining NLME Models","title":"The observed Function","text":"","category":"section"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"The observed function takes in the collated preprocessed values col, the DESolution sol, the obstimes, the sampled derived values samples, and the full subject data. The output value is the simulation output. It can be any Julia type. For example, the following is a valid observed function:","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"function observed(col,sol,obstimes,samples,subject)\r\n    (obs_cmax = maximum(samples.dv),\r\n     T_max = maximum(obstimes),\r\n     dv = samples.dv)\r\nend","category":"page"},{"location":"basics/models/#","page":"Defining NLME Models","title":"Defining NLME Models","text":"Note that if the observed function is not given to the PuMaSModel constructor, the default function (col,sol,obstimes,samples,subject)->samples which passes through the sampled derived values is used.","category":"page"},{"location":"basics/doses_subjects_populations/#Dosage-Regimens,-Subjects,-and-Populations-1","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"","category":"section"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"The data is passed to a PuMaS model via the Population type. A Population is a collection of Subjects. In this section we will specify the methods used for defining Subjects and Populations. These types can either be defined programmatically using the Subject and Population constructors on Julia types or by using the PuMaS NLME Data format (named PuMaSNDF).","category":"page"},{"location":"basics/doses_subjects_populations/#Dosage-Regimen-Terminology-1","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimen Terminology","text":"","category":"section"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"Both the DosageRegimen and the PuMaSNDF utilize the same terminology for describing a dose. The definition of the values are as follows:","category":"page"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"amt: the amount of the dose. This is the only required value.\ntime: the time at which the dose is given. Defaults to 0.\nevid: the event id. 1 specifies a normal event. 3 means it's a reset event, meaning that the value of the dynamical variable is reset to the amt at the dosing event. If 4, then the value is reset (to the steady state), and then a final dose is given. Defaults to 1.\nii: the interdose interval. For steady state events, this is the length of time between successive doses. When addl is specified, this is the length of time to the next dose. Defaults to 0.\naddl: the number of additional events of the same types, spaced by ii. Defaults to 0.\nrate: the rate of administration. If 0, then the dose is instantaneous. Otherwise the dose is administrated at a constant rate for a duration equal to amt/rate.\nss: an indicator for whether the dose is a steady state dose. A steady state dose is defined as the result of having applied the dose with the interval ii infinitely many successive times. 0 indicates that the dose is not a steady state dose. 1 indicates that the dose is a steady state dose. 2 indicates that it is a steady state dose that is added to the previous amount. The default is 0.","category":"page"},{"location":"basics/doses_subjects_populations/#The-Subject-Constructor-1","page":"Dosage Regimens, Subjects, and Populations","title":"The Subject Constructor","text":"","category":"section"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"A Subject can be constructed using the following constructor:","category":"page"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"Subject(;id = 1,\r\n         obs = nothing,\r\n         cvs = nothing,\r\n         evs = Event[],\r\n         time = obs isa AbstractDataFrame ? obs.time : nothing\r\n         )","category":"page"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"The definitions of the arguments are as follows:","category":"page"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"id is the id of the subject. Defaults to 1.\nobs is a Julia type which holds the observational data. When using the @model interface, this must be a NamedTuple whose names match those of the derived variables.\ncvs are the covariates for the subject. It can be any Julia type when working with the function-based interface, but must be a NamedTuple for the @model interface. Defaults to nothing, meaning no covariates.\nevs is a DosageRegimen. Defaults to an empty event list.\ntime is the list of times associated with the observations.","category":"page"},{"location":"basics/doses_subjects_populations/#DosageRegimen-1","page":"Dosage Regimens, Subjects, and Populations","title":"DosageRegimen","text":"","category":"section"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"The DosageRegimen type is a specification of a regimen. Its constructor is:","category":"page"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"DosageRegimen(amt;\r\n              time = 0,\r\n              cmt  = 1,\r\n              evid = 1,\r\n              ii   = zero.(time),\r\n              addl = 0,\r\n              rate = zero.(amt)./oneunit.(time),\r\n              ss   = 0)","category":"page"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"Each of the values can either be AbstractVectors or scalars. All vectors must be of the same length, and the elementwise combinations each define an event (with scalars being repeated).","category":"page"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"Additionally, multiple DosageRegimens can be combined to form a DosageRegimen. For example, if we have:","category":"page"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"dr1 = DosageRegimen(100, ii = 24, addl = 6)\r\ndr2 = DosageRegimen(50,  ii = 12, addl = 13)\r\ndr3 = DosageRegimen(200, ii = 24, addl = 2)","category":"page"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"then the following is the DosageRegimen for the combination of all doses:","category":"page"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"dr = DosageRegimen(e1, e2, e3)","category":"page"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"The current DosageRegimen can be viewed in its tabular form using the DataFrame function: DataFrame(dr).","category":"page"},{"location":"basics/doses_subjects_populations/#The-Population-Constructor-1","page":"Dosage Regimens, Subjects, and Populations","title":"The Population Constructor","text":"","category":"section"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"The Population constructor is simply Population(subjects), where subjects is a collection of Subjects.","category":"page"},{"location":"basics/doses_subjects_populations/#PuMaSNDF-1","page":"Dosage Regimens, Subjects, and Populations","title":"PuMaSNDF","text":"","category":"section"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"The PuMaSNDF is a specification for building a Population from tabular data. Generally this tabular data is given by a database like a CSV. The CSV has columns described as follows:","category":"page"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"id: the ID of the individual. Each individual should have a unique integer, or string.\ntime: the time corresponding to the row. Should be unique per id, i.e. no duplicate time values for a given subject.\nevid: the event id. 1 specifies a normal event. 3 means it's a reset event, meaning that the value of the dynamical variable is reset to the amt at the dosing event. If 4, then the value is reset (to the steady state), and then a final dose is given. Defaults to 0 if amt is 0 or missing, and 1 otherwise.\namt: the amount of the dose. If the evid column exists and is non-zero, this value should be non-zero. Defaults to 0.\nii: the interdose interval. When addl is specified, this is the length of time to the next dose. For steady state events, this is the length of time between successive doses. Defaults to 0, and is required to be non-zero on rows where a steady-state event is specified.  \naddl: the number of additional doses of the same time to give. Defaults to 0.\nrate: the rate of administration. If 0, then the dose is instantaneous. Otherwise the dose is administrated at a constant rate for a duration equal to amt/rate. A rate=-2 allows the rate to be determined by a dosing control parameter. Defaults to 0.\nss: an indicator for whether the dose is a steady state dose. A steady state dose is defined as the result of having applied the dose with the interval ii infinitely many successive times. 0 indicates that the dose is not a steady state dose. 1 indicates that the dose is a steady state dose. 2 indicates that it is a steady state dose that is added to the previous amount. The default is 0.\ncmt: the compartment being dosed. Defaults to 1.\nduration: the duration of administration. If 0, then the dose is instantaneous. Otherwise the dose is administered at a constant rate equal to amt/duration. Defaults to 0.\nObservation and covariate columns should be given as a time series of values of matching type. Constant covariates should be constant through the full column. Time points without a measurement should be denoted by a ..","category":"page"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"If a column does not exists, its values are imputed to be the defaults. Special notes:","category":"page"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"If rate and duration exist, then it is enforced that amt=rate*duration\nAll values and header names are interpreted as lower case.","category":"page"},{"location":"basics/doses_subjects_populations/#PuMaSNDF-Parsing-1","page":"Dosage Regimens, Subjects, and Populations","title":"PuMaSNDF Parsing","text":"","category":"section"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"process_nmtran(data,cvs=Symbol[],dvs=Symbol[:dv];\r\n                        id=:id, time=:time, evid=:evid, amt=:amt, addl=:addl,\r\n                        ii=:ii, cmt=:cmt, rate=:rate, ss=:ss)","category":"page"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"The arguments are as follows:","category":"page"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"data is the tabular data source. If a string path to a CSV is given, then it will read the CSV file from that location in the file system. If a Julia-based tabular data structure is given, such as a DataFrame, then that structure will be used as the data source.\ncvs is the list of symbols for the header names of the covariate columns.\ndvs is the list of symbols for the header names of the observation data columns.","category":"page"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"The other arguments are optional and allow changing the column names from their default.","category":"page"},{"location":"basics/doses_subjects_populations/#NMTRAN-Parsing-1","page":"Dosage Regimens, Subjects, and Populations","title":"NMTRAN Parsing","text":"","category":"section"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"Additionally, there exist a parsing function process_nmtran for parsing general NONMEM files. This function is a work-in-progress.","category":"page"},{"location":"basics/doses_subjects_populations/#","page":"Dosage Regimens, Subjects, and Populations","title":"Dosage Regimens, Subjects, and Populations","text":"process_nmtran(data,cvs=Symbol[],dvs=Symbol[:dv];\r\n                        id=:id, time=:time, evid=:evid, amt=:amt, addl=:addl,\r\n                        ii=:ii, cmt=:cmt, rate=:rate, ss=:ss)","category":"page"},{"location":"basics/simulation/#Simulation-of-PuMaS-Models-1","page":"Simulation of PuMaS Models","title":"Simulation of PuMaS Models","text":"","category":"section"},{"location":"basics/simulation/#The-simobs-Function-1","page":"Simulation of PuMaS Models","title":"The simobs Function","text":"","category":"section"},{"location":"basics/simulation/#","page":"Simulation of PuMaS Models","title":"Simulation of PuMaS Models","text":"Simulation of a PuMaSModel are performed via the simobs function. The function is given by the values:","category":"page"},{"location":"basics/simulation/#","page":"Simulation of PuMaS Models","title":"Simulation of PuMaS Models","text":"simobs(m,data,param,[randeffs];kwargs...)","category":"page"},{"location":"basics/simulation/#","page":"Simulation of PuMaS Models","title":"Simulation of PuMaS Models","text":"The terms in the function call are:","category":"page"},{"location":"basics/simulation/#","page":"Simulation of PuMaS Models","title":"Simulation of PuMaS Models","text":"m: the PuMaSModel, either defined via the @model DSL or the function-based interface.\ndata: either a Subject or a Population.\nparam: a NamedTuple of parameters which conform to the ParamSet of the model.\nrandeffs: an optional argument for the random effects for the simulation. If the random effects are not given, they are sampled as described in the model.\nkwargs: extra keyword arguments.","category":"page"},{"location":"basics/simulation/#","page":"Simulation of PuMaS Models","title":"Simulation of PuMaS Models","text":"Additionally, the following keyword arguments can be used:","category":"page"},{"location":"basics/simulation/#","page":"Simulation of PuMaS Models","title":"Simulation of PuMaS Models","text":"alg: the type for which differential equation solver method to use. For example, alg=Rodas5() specifies the usage of the 5th order Rosenbrock method for ODEs described in the DifferentialEquations.jl solver documentation page. Defaults to an automatic stiffness detection algorithm for ODEs.\nparallel_type: the type of parallelism to use internally for simulating a Population. The options are:\nPuMaS.Serial: No parallelism.\nPuMaS.Threads: Shared memory multithreading.\nPuMaS.Distributed: Distributed (multinode, multi-computer) parallelism.\nThe default is PuMaS.Threads.\nAny keyword argument in the DifferentialEquations.jl common solver arguments. These are documented on the DifferentialEquations.jl common solver options page.","category":"page"},{"location":"basics/simulation/#","page":"Simulation of PuMaS Models","title":"Simulation of PuMaS Models","text":"The result of simobs function is a SimulatedObservation if the data was Subject and a SimulatedPopulation if the data was a Population.","category":"page"},{"location":"basics/simulation/#Handling-Simulated-Returns-1","page":"Simulation of PuMaS Models","title":"Handling Simulated Returns","text":"","category":"section"},{"location":"basics/simulation/#","page":"Simulation of PuMaS Models","title":"Simulation of PuMaS Models","text":"When running","category":"page"},{"location":"basics/simulation/#","page":"Simulation of PuMaS Models","title":"Simulation of PuMaS Models","text":"sim = simobs(m,data,param)","category":"page"},{"location":"basics/simulation/#","page":"Simulation of PuMaS Models","title":"Simulation of PuMaS Models","text":"sim is a SimulatedObservation which can be accessed via its fields. These fields are:","category":"page"},{"location":"basics/simulation/#","page":"Simulation of PuMaS Models","title":"Simulation of PuMaS Models","text":"subject: the Subject used to generate the observation\ntimes: the times associated with the observations\nobserved: the resulting observations of the simulation","category":"page"},{"location":"basics/simulation/#","page":"Simulation of PuMaS Models","title":"Simulation of PuMaS Models","text":"If the @model DSL is used, then observed is a NamedTuple where the names give the associated values. From the function-based interface, observed is the chosen return type of the observed function in the model specification.","category":"page"},{"location":"basics/simulation/#","page":"Simulation of PuMaS Models","title":"Simulation of PuMaS Models","text":"A SimulatedPopulation is a collection of SimulatedObservations, and when indexed like sim[i] it returns the SimulatedObservation of the ith simulation subject.","category":"page"},{"location":"basics/simulation/#Visualizing-Simulated-Returns-1","page":"Simulation of PuMaS Models","title":"Visualizing Simulated Returns","text":"","category":"section"},{"location":"basics/simulation/#","page":"Simulation of PuMaS Models","title":"Simulation of PuMaS Models","text":"These objects have automatic plotting and dataframe visualization. To plot a simulation return, simply call plot on the output using Plots.jl. For example, the following will run a simulation and plot the observed variables:","category":"page"},{"location":"basics/simulation/#","page":"Simulation of PuMaS Models","title":"Simulation of PuMaS Models","text":"obs = simobs(m,data,param)\r\nusing Plots\r\nplot(obs)","category":"page"},{"location":"basics/simulation/#","page":"Simulation of PuMaS Models","title":"Simulation of PuMaS Models","text":"By default this generates a plot for each derived variable. To choose which variables to plot, the obsnames argument can be given which declares indices or derived variable names to plot. For example, plot(obs,obsnames=[:dv1,:dv2]) would only plot the values dv1 and dv2. In addition, all of the Plots.jl attributes can be used in this plot command. For more information on using Plots.jl, please see the Plots.jl tutorial. Note that if the simulated return is a SimulatedPopulation, then the plots overlay the results of the various subjects.","category":"page"},{"location":"basics/simulation/#","page":"Simulation of PuMaS Models","title":"Simulation of PuMaS Models","text":"To generate the DataFrame associated with the observed outputs, simply call DataFrame on the simulated return. For example, the following builds the tabular output from the returned object:","category":"page"},{"location":"basics/simulation/#","page":"Simulation of PuMaS Models","title":"Simulation of PuMaS Models","text":"obs = simobs(m,data,param)\r\ndf = DataFrame(obs)","category":"page"},{"location":"basics/estimation/#Estimating-Parameters-of-PuMaS-Models-1","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"","category":"section"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"PuMaS can use the observational data of a Subject or Population to estimate the parameters of an NLME model. This is done by two classes of methods. Maximum likelihood methods find the parameters such that the observational data has the highest probability of occurring according to the chosen error distributions. Bayesian methods find a posterior probability distribution for the parameters to describe the chance that a parameter has a given value given the data. The following section describes how to fit an NLME model in PuMaS via the two methods.","category":"page"},{"location":"basics/estimation/#Defining-Data-for-Estimation-1","page":"Estimating Parameters of PuMaS Models","title":"Defining Data for Estimation","text":"","category":"section"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"Estimation is done by looking at the likelihood of likewise names. Thus, for example if subject.observations is a NamedTuple with names dv and resp, the likelihood calculation will be between values from derived named dv and resp. If dv is a scalar in the observation data, then dv from derived should also be a scalar. Likewise, if dv is an array like a time series, then dv should be a size-matching time series when returned from derived. Note that likelihoods are calculated between the probability distribution from derived and the matching observation from subject.observations. If no likelihood is associated with a derived value, then the value has an implicit standard normal interpretation, which amounts to having the L2 Euclidian distance taken as the likelihood during fitting procedures.","category":"page"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"Note: Currently only BayesMCMC and LaplaceI support multiple output series. all other likelihood approximations must have the derived and observation data under the name dv","category":"page"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"Note: Currently the estimation procedures require that there only exists a single random effect (vector), and this vector must be named η (\\eta)","category":"page"},{"location":"basics/estimation/#Maximum-Likelihood-Estimation-1","page":"Estimating Parameters of PuMaS Models","title":"Maximum Likelihood Estimation","text":"","category":"section"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"Maximum Likelihood Estimation (MLE) is performed using the fit function. This function's signature is:","category":"page"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"Distributions.fit(m::PuMaSModel,\r\n                  data::Population,\r\n                  param::NamedTuple,\r\n                  approx::LikelihoodApproximation,\r\n                  args...;\r\n                  optimize_fn = DEFAULT_OPTIMIZE_FN,\r\n                  kwargs...)","category":"page"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"The arguments are:","category":"page"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"m: a PuMaSModel, either defined by the @model DSL or the function-based interface.\ndata: a Population.\nparam: a named tuple of parameters. Used as the initial condition for the optimizer.\napprox: the marginal loglikelihood approximation to use for the maximum likelihood procedure.\nExtra args and kwargs are passed on to the internal simobs call and thus control the behavior of the differential equation solvers.\noptimize_fn: a function of two arguments (cost,p) where cost is the cost function and p is the initial parameters as a vector. This function defines the optimization routine that is used to find the maximum of the likelihood. The default optimization function uses the Optim.jl library and is defined as follows:","category":"page"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"function DEFAULT_OPTIMIZE_FN(cost,p)\r\n  Optim.optimize(cost,p,BFGS(linesearch=Optim.LineSearches.BackTracking()),\r\n                 Optim.Options(show_trace=verbose, # Print progress\r\n                               store_trace=true,\r\n                               extended_trace=true,\r\n                               g_tol=1e-3),\r\n                  autodiff=:finite)\r\nend","category":"page"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"The return type of fit is a FittedPuMaSModel.","category":"page"},{"location":"basics/estimation/#Marginal-Likelihood-Approximations-1","page":"Estimating Parameters of PuMaS Models","title":"Marginal Likelihood Approximations","text":"","category":"section"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"The following choices are available for the likelihood approximations:","category":"page"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"FO(): first order approximation.\nFOI(): first order approximation with interaction. Not complete.\nFOCE(): first order conditional estimation.\nFOCEI(): first order conditional estimation with interaction.\nLaplace(): second order Laplace approximation\nLaplaceI(): second order Laplace approximation with interaction.","category":"page"},{"location":"basics/estimation/#FittedPuMaSModel-1","page":"Estimating Parameters of PuMaS Models","title":"FittedPuMaSModel","text":"","category":"section"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"The relevant fields of a FittedPuMaSModel are:","category":"page"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"model: the model used in the estimation process.\ndata: the Population that was estimated.\napprox: the marginal likelihood approximation that was used.\nparam: the optimal parameters.","category":"page"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"Additionally, the following functions help interpret the fit:","category":"page"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"vcov(fpm) returns the covariance matrix between the population parameters for the FittedPuMaSModel\nstderror(fpm) returns the standard errors for the population parameters for the FittedPuMaSModel","category":"page"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"Additionally the function:","category":"page"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"predict(fpm::FittedPuMaSModel, approx=fpm.approx;\r\n        nsim=nothing, timegrid=false, newdata=false, useEBEs=true)","category":"page"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"Returns a FittedPuMaSPrediction which contains the solution of all population diagnostics in the field population and all individual diagnostics in the field individual. For more information on the diagnostics, please see the Diagnostics page","category":"page"},{"location":"basics/estimation/#Bayesian-Estimation-1","page":"Estimating Parameters of PuMaS Models","title":"Bayesian Estimation","text":"","category":"section"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"Bayesian parameter estimation is performed by using the fit function as follows:","category":"page"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"fit(model::PuMaSModel, data::Population, ::BayesMCMC,\r\n                       args...; nsamples=5000, kwargs...)","category":"page"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"The arguments are:","category":"page"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"m: a PuMaSModel, either defined by the @model DSL or the function-based interface.\ndata: a Population.\nThe approx must be BayesMCMC().\nnsamples determines the number of samples taken along each chain.\nExtra args and kwargs are passed on to the internal simobs call and thus control the behavior of the differential equation solvers.","category":"page"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"The result is a BayesMCMCResults type. Notice that initial parameter values are not utilized in Bayesian estimation.","category":"page"},{"location":"basics/estimation/#BayesMCMCResults-1","page":"Estimating Parameters of PuMaS Models","title":"BayesMCMCResults","text":"","category":"section"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"The MCMC chain is stored in the chain field of the returned BayesMCMCResults. The following functions help with querying common results on the Bayesian posterior:","category":"page"},{"location":"basics/estimation/#","page":"Estimating Parameters of PuMaS Models","title":"Estimating Parameters of PuMaS Models","text":"param_mean(br): returns a named tuple of parameters which represents the mean of each parameter's posterior distribution\nparam_var(br): returns a named tuple of parameters which represents the variance of each parameter's posterior distribution\nparam_std(br): returns a named tuple of parameters which represents the standard deviation of each parameter's posterior distribution","category":"page"},{"location":"basics/nca/#Noncompartmental-Analysis-(NCA)-1","page":"Noncompartmental Analysis (NCA)","title":"Noncompartmental Analysis (NCA)","text":"","category":"section"},{"location":"basics/nca/#","page":"Noncompartmental Analysis (NCA)","title":"Noncompartmental Analysis (NCA)","text":"NCA is performed in PuMaS by creating NCASubject and NCAPopulation types which then preprocess the data to allow for easy generation of all NCA values. These types come with plotting, DataFrame, and report overloads to ease the analysis process.","category":"page"},{"location":"basics/nca/#The-NCASubject-and-NCAPopulation-constructors-1","page":"Noncompartmental Analysis (NCA)","title":"The NCASubject and NCAPopulation constructors","text":"","category":"section"},{"location":"basics/nca/#","page":"Noncompartmental Analysis (NCA)","title":"Noncompartmental Analysis (NCA)","text":"The NCASubject constructor is as follows:","category":"page"},{"location":"basics/nca/#","page":"Noncompartmental Analysis (NCA)","title":"Noncompartmental Analysis (NCA)","text":"NCASubject(conc, time;\r\n           concu=true, timeu=true,\r\n           id=1, group=nothing, dose=nothing, llq=nothing, clean=true,\r\n           lambdaz=nothing, ii=nothing, kwargs...)","category":"page"},{"location":"basics/nca/#","page":"Noncompartmental Analysis (NCA)","title":"Noncompartmental Analysis (NCA)","text":"conc is the timeseries of concentrations to analyze and time is the time points which correspond to the time series. The keyword arguments are:","category":"page"},{"location":"basics/nca/#","page":"Noncompartmental Analysis (NCA)","title":"Noncompartmental Analysis (NCA)","text":"ii: the inter-dose interval between doses (for multiple doses)","category":"page"},{"location":"basics/nca/#","page":"Noncompartmental Analysis (NCA)","title":"Noncompartmental Analysis (NCA)","text":"An NCAPopulation takes in a vector of NCASubject and allows for the analysis on multiple subjects at once.","category":"page"},{"location":"basics/nca/#The-NCA-Functions-1","page":"Noncompartmental Analysis (NCA)","title":"The NCA Functions","text":"","category":"section"},{"location":"basics/nca/#","page":"Noncompartmental Analysis (NCA)","title":"Noncompartmental Analysis (NCA)","text":"A description of the NCA output functions are as follows:","category":"page"},{"location":"basics/nca/#","page":"Noncompartmental Analysis (NCA)","title":"Noncompartmental Analysis (NCA)","text":"auc: the area under the curve.","category":"page"},{"location":"basics/nca/#","page":"Noncompartmental Analysis (NCA)","title":"Noncompartmental Analysis (NCA)","text":"These functions are all accessed from within the NCA submodule. For example, to use auc on NCAPopulation, one would use NCA.auc(ncapop).","category":"page"},{"location":"basics/nca/#Analysis-Functionality-(Plots,-Reports,-DataFrame)-1","page":"Noncompartmental Analysis (NCA)","title":"Analysis Functionality (Plots, Reports, DataFrame)","text":"","category":"section"},{"location":"basics/nca/#PuMaSNCADF-1","page":"Noncompartmental Analysis (NCA)","title":"PuMaSNCADF","text":"","category":"section"},{"location":"basics/nca/#","page":"Noncompartmental Analysis (NCA)","title":"Noncompartmental Analysis (NCA)","text":"The PuMaSNCADF is a standardized format for tabular data for NCA. The format has the following columns:","category":"page"},{"location":"basics/nca/#","page":"Noncompartmental Analysis (NCA)","title":"Noncompartmental Analysis (NCA)","text":"id: The string id of the subject.\nconc: the concentration time series measurements. Values must be floating point numbers or missing.\ntime: the time at which the concentration was measured.\noccasion: the occasion for the observation. Must be an integer value at each time point.\namt: the amount of a dose. Must be a floating point value at each dosing time, and otherwise missing.\nroute: the route of administration. Possible choices are iv for intravenous, ev for extravascular, and inf for infusion.\nduration: the infusion duration. Should be a floating point value or missing.\nGrouping variables: Any additional column may be chosen as for grouping the output by.","category":"page"},{"location":"basics/nca/#Parsing-PuMaSNCADF-1","page":"Noncompartmental Analysis (NCA)","title":"Parsing PuMaSNCADF","text":"","category":"section"},{"location":"basics/nca/#","page":"Noncompartmental Analysis (NCA)","title":"Noncompartmental Analysis (NCA)","text":"The parsing function for the PuMaSNCADF is as follows:","category":"page"},{"location":"basics/nca/#","page":"Noncompartmental Analysis (NCA)","title":"Noncompartmental Analysis (NCA)","text":"read_nca(df; group=nothing, ii=:ii, ss=:ss,\r\n                  concu=true, timeu=true, amtu=true, verbose=true)","category":"page"},{"location":"basics/nca/#","page":"Noncompartmental Analysis (NCA)","title":"Noncompartmental Analysis (NCA)","text":"These arguments are:","category":"page"},{"location":"basics/nca/#","page":"Noncompartmental Analysis (NCA)","title":"Noncompartmental Analysis (NCA)","text":"df: the required positional argument. This is either a string which is the path to a CSV file, or a DataFrame of tabular data for use in the NCA.\ngroup: the column to group the output by. Defaults to no grouping.\nii: the interdose interval. Used to specify the interval length for steady state dosing.\nss: the steady-state. Used to specify whether a dose is steady-state, a steady-state dose takes the value 1 and 0 otherwise. Defaults to the :ss column.\nconcu: the units for concentration. Defaults to no units.\namtu: the units for dosing amount. Defaults to no units.\ntimeu: the units for time. Defaults to no units.\nverbose: When true, warnings will be thrown when the output is does not match PuMaSNCADF. Defaults to true.","category":"page"},{"location":"basics/faq/#Frequently-Asked-Questions-(FAQ)-1","page":"Frequently Asked Questions (FAQ)","title":"Frequently Asked Questions (FAQ)","text":"","category":"section"},{"location":"model_components/domains/#Domains-1","page":"Domains","title":"Domains","text":"","category":"section"},{"location":"model_components/domains/#","page":"Domains","title":"Domains","text":"Domains are used to define the param portion of a PuMaSModel. This segment of the documentation describes the available Domain types that can be used within the param portions.","category":"page"},{"location":"model_components/domains/#Matching-Parameter-Types-and-Domains-1","page":"Domains","title":"Matching Parameter Types and Domains","text":"","category":"section"},{"location":"model_components/domains/#","page":"Domains","title":"Domains","text":"A param specification in a PuMaSModel directly defines the types which are required to be given as the input to the model's API functions such as simobs and fit. For example, if the param specification is given as:","category":"page"},{"location":"model_components/domains/#","page":"Domains","title":"Domains","text":"@param begin\r\n    θ ∈ VectorDomain(2, lower=[0.0,0.0], upper=[20.0,20.0])\r\n    Ω ∈ PSDDomain(2)\r\n    Σ ∈ ConstDomain(0.1)\r\nend","category":"page"},{"location":"model_components/domains/#","page":"Domains","title":"Domains","text":"Then in simobs(model,data,param) or fit(model,data,param), the parameters param must be a NamedTuple of values where the type fits in the domain. For example, param must have param.θ as a Vector. Thus the following would be a valid definition of param for this structure:","category":"page"},{"location":"model_components/domains/#","page":"Domains","title":"Domains","text":"param = (\r\n    θ = [0.4, 7.0],\r\n    Ω=PuMaS.PDMat([0.04 0.0\r\n                   0.0  0.01]),\r\n    Σ = 0.1\r\n    )","category":"page"},{"location":"model_components/domains/#","page":"Domains","title":"Domains","text":"Below are the specifications of the Domain types and their matching value types.","category":"page"},{"location":"model_components/domains/#RealDomain-and-VectorDomain-1","page":"Domains","title":"RealDomain and VectorDomain","text":"","category":"section"},{"location":"model_components/domains/#","page":"Domains","title":"Domains","text":"RealDomain and VectorDomain are the core domain types of PuMaS. A RealDomain defines a scalar value which exists in the real line, while a VectorDomain defines a real-valued vector which lives in a hypercube of mathbbR^n. The length n of a VectorDomain is a required positional argument. Each of these allow keyword arguments for setting an upper and lower bound for the segment, where for the RealDomain these are scalars and for the VectorDomain it is a vector of upper and lower bound for each component of the vector. Thus the constructors are:","category":"page"},{"location":"model_components/domains/#","page":"Domains","title":"Domains","text":"RealDomain(;upper,lower)\r\nVectorDomain(n;upper,lower)","category":"page"},{"location":"model_components/domains/#","page":"Domains","title":"Domains","text":"A RealDomain requires that the matching parameters are an AbstractFloat type. A VectorDomain requires that the matching parameters are a Vector of an AbstactFloat type which has the correct size.","category":"page"},{"location":"model_components/domains/#ConstDomain-1","page":"Domains","title":"ConstDomain","text":"","category":"section"},{"location":"model_components/domains/#","page":"Domains","title":"Domains","text":"ConstDomain is a special domain type which is like RealDomain but is held constant during parameter estimation and fitting routines. A ConstDomain is defined by its value:","category":"page"},{"location":"model_components/domains/#","page":"Domains","title":"Domains","text":"ConstDomain(val)","category":"page"},{"location":"model_components/domains/#","page":"Domains","title":"Domains","text":"A ConstDomain requires the matching value in the parameters.","category":"page"},{"location":"model_components/domains/#Positive-Definite-Matrix-Domains-1","page":"Domains","title":"Positive-Definite Matrix Domains","text":"","category":"section"},{"location":"model_components/domains/#","page":"Domains","title":"Domains","text":"In many cases, one may wish to specify a positive-definite covariance matrix as a parameter in a model. A common use case for this functionality is for defining the sampling domain of a random effect. There are two domains for positive-definite matrices: PSDDomain and PDiagDomain. Both of the constructors require the size n of the NxN postive-definite matrix:","category":"page"},{"location":"model_components/domains/#","page":"Domains","title":"Domains","text":"PSDDomain(n)\r\nPDiagDomain(n)","category":"page"},{"location":"model_components/domains/#","page":"Domains","title":"Domains","text":"A PSDDomain requires that the matching parameter is a PDMat, Julia's positive-definite matrix type. A PDMat is generated by passing in a Julia matrix. For example, if a domain is specified as Ω ∈ PSDDomain(2), then","category":"page"},{"location":"model_components/domains/#","page":"Domains","title":"Domains","text":"Ω = PuMaS.PDMat([0.04 0.0\r\n                 0.0  0.01])","category":"page"},{"location":"model_components/domains/#","page":"Domains","title":"Domains","text":"is a valid parameter specification. Likewise, a PDiagDomain is defined by a PDiagMat which is generated by passing a vector for the diagonal. Thus, if a domain is specified as Ω ∈ PDiagDomain(2), then","category":"page"},{"location":"model_components/domains/#","page":"Domains","title":"Domains","text":"Ω = PuMaS.PDiagMat([0.0,1.0])","category":"page"},{"location":"model_components/domains/#","page":"Domains","title":"Domains","text":"is a valid parameter specification.","category":"page"},{"location":"model_components/domains/#Distributional-Domains-1","page":"Domains","title":"Distributional Domains","text":"","category":"section"},{"location":"model_components/domains/#","page":"Domains","title":"Domains","text":"Instead of using a Domain type from PuMaS, a Distribution can be used to specify a domain. For example,","category":"page"},{"location":"model_components/domains/#","page":"Domains","title":"Domains","text":"Ω ~ Normal(0,1)","category":"page"},{"location":"model_components/domains/#","page":"Domains","title":"Domains","text":"is a valid domain specification. If this is done, then the probability distribution is used and interpreted as the prior distribution. Implicitly, the domain of a distribution is treated as the support of the distribution. A distributional domain requires that the matching parameter is of the same type as a sample from the domain. For example, if Ω ~ Normal(0,1), then Ω should be given as a scalar.","category":"page"},{"location":"model_components/domains/#Constrained-1","page":"Domains","title":"Constrained","text":"","category":"section"},{"location":"model_components/domains/#","page":"Domains","title":"Domains","text":"The Constrained domain is for defining a Constrained probability distribution. Constrained takes in a distribution and has keyword arguments for upper and lower bounds. For example, ψ ~ Constrained(MVNormal(Ω),lower=[0.0,0.0]) defines a ψ to be from the distributional domain which corresponds to a multivariate normal distribution, but is constrained to be positive. Like with the distributional domains, Constrained requires that the matching parameter is of the same type as a sample from the domain.","category":"page"},{"location":"model_components/dosing_control/#Dosing-Control-Parameters-(DCP)-1","page":"Dosing Control Parameters (DCP)","title":"Dosing Control Parameters (DCP)","text":"","category":"section"},{"location":"model_components/dosing_control/#","page":"Dosing Control Parameters (DCP)","title":"Dosing Control Parameters (DCP)","text":"The pre part of a PuMaSModel allows for specifying special preprocessed parameters known as the Dosing Control Parameters (DCP). Unlike standard parameters which are for use in the proceeding blocks, the DCP are used to modify the internal event handling of the PuMaS. The DCP are defined as follows:","category":"page"},{"location":"model_components/dosing_control/#","page":"Dosing Control Parameters (DCP)","title":"Dosing Control Parameters (DCP)","text":"lags: the lag of the dose. A dose with a lag will take place at time t = dosetime + lag. Default is zero.\nbioav: the bioavailability of the dose. The true dose is equal to bioav*amt where amt is the dose amount from the dosage regimen. Default is 1.\nrate: the rate of the dosing.\nduration: the duration of the dose.","category":"page"},{"location":"model_components/dosing_control/#","page":"Dosing Control Parameters (DCP)","title":"Dosing Control Parameters (DCP)","text":"rate and duration handling are intertwined and always satisfy the relation amt = rate*duration. Any two of the values are given, the third is automatically defined. If both rate and duration are specified, then an error will be given unless amt = rate*duration is satisfied.","category":"page"},{"location":"model_components/dosing_control/#Input-Definition-1","page":"Dosing Control Parameters (DCP)","title":"Input Definition","text":"","category":"section"},{"location":"model_components/dosing_control/#","page":"Dosing Control Parameters (DCP)","title":"Dosing Control Parameters (DCP)","text":"If a DCP is defined as a scalar, then it applies to all doses. For example, if a pre block contains the definition:","category":"page"},{"location":"model_components/dosing_control/#","page":"Dosing Control Parameters (DCP)","title":"Dosing Control Parameters (DCP)","text":"lags = θ","category":"page"},{"location":"model_components/dosing_control/#","page":"Dosing Control Parameters (DCP)","title":"Dosing Control Parameters (DCP)","text":"and θ is a scalar, then every dose will be lagged by the parameter θ. Likewise, if a DCP is defined as a collection, then the value of the collection corresponding to the cmt of the dose specifies the DCP. For example:","category":"page"},{"location":"model_components/dosing_control/#","page":"Dosing Control Parameters (DCP)","title":"Dosing Control Parameters (DCP)","text":"lags = [2,0]","category":"page"},{"location":"model_components/dosing_control/#","page":"Dosing Control Parameters (DCP)","title":"Dosing Control Parameters (DCP)","text":"implies that any dose into cmt=1 will have a lag of 2, while any dose into cmt=2 will have a lag of 0.","category":"page"},{"location":"model_components/dosing_control/#","page":"Dosing Control Parameters (DCP)","title":"Dosing Control Parameters (DCP)","text":"Note: the ability to specify a DCP by a NamedTuple with names matching the dynamical parameters is in development","category":"page"},{"location":"model_components/dynamical_types/#Dynamical-Problem-Types-1","page":"Dynamical Problem Types","title":"Dynamical Problem Types","text":"","category":"section"},{"location":"model_components/dynamical_types/#","page":"Dynamical Problem Types","title":"Dynamical Problem Types","text":"The dynamical problem types specify the dynamical models that are the nonlinear transformation of the NLME model. There are two major types of dynamical models: analytical models and DEProblems. An analytical model is a small differential equation with an analytical solution. This analytical solution is used by the solvers to greatly enhance the performance. On the other hand, DEProblem is a specification of a differential equation for numerical solution by DifferentialEquations.jl. This is used for specifying dynamical equations which do not have an analytical solution, such as many nonlinear ordinary differential equations (ODEs), or the myriad of differential equation types supported by DifferentialEquations.jl, such as delay differential equations (DDEs) and stochastic differential equations (SDEs).","category":"page"},{"location":"model_components/dynamical_types/#Analytical-Problems-1","page":"Dynamical Problem Types","title":"Analytical Problems","text":"","category":"section"},{"location":"model_components/dynamical_types/#","page":"Dynamical Problem Types","title":"Dynamical Problem Types","text":"Analytical problems are a predefined ODE with an analytical solution. While limited in flexibility, the analytical solutions can be much faster for simulation and estimation. In the @model DSL, an analytical solution is declared by name. For example:","category":"page"},{"location":"model_components/dynamical_types/#","page":"Dynamical Problem Types","title":"Dynamical Problem Types","text":"@dynamics ImmediateAbsorptionModel","category":"page"},{"location":"model_components/dynamical_types/#","page":"Dynamical Problem Types","title":"Dynamical Problem Types","text":"declares the use of the ImmediateAbsorptionModel. Analytical solutions have preset names which are used in the internal model. These parameters must be given values in the pre block.","category":"page"},{"location":"model_components/dynamical_types/#ImmediateAbsorptionModel-1","page":"Dynamical Problem Types","title":"ImmediateAbsorptionModel","text":"","category":"section"},{"location":"model_components/dynamical_types/#","page":"Dynamical Problem Types","title":"Dynamical Problem Types","text":"The ImmediateAbsorptionModel corresponds to the ODE:","category":"page"},{"location":"model_components/dynamical_types/#","page":"Dynamical Problem Types","title":"Dynamical Problem Types","text":"Central = -(CLV)*Central\r\nendalign","category":"page"},{"location":"model_components/dynamical_types/#OneCompartmentModel-1","page":"Dynamical Problem Types","title":"OneCompartmentModel","text":"","category":"section"},{"location":"model_components/dynamical_types/#","page":"Dynamical Problem Types","title":"Dynamical Problem Types","text":"The OneCompartmentModel corresponds to the ODE:","category":"page"},{"location":"model_components/dynamical_types/#","page":"Dynamical Problem Types","title":"Dynamical Problem Types","text":"beginalign\r\nDepot   = -Ka*Depot\r\nCentral =  Ka*Depot - (CLV)*Central\r\nendalign","category":"page"},{"location":"model_components/dynamical_types/#OneCompartmentParallelModel-1","page":"Dynamical Problem Types","title":"OneCompartmentParallelModel","text":"","category":"section"},{"location":"model_components/dynamical_types/#","page":"Dynamical Problem Types","title":"Dynamical Problem Types","text":"The OneCompartmentParallelModel corresponds to the ODE:","category":"page"},{"location":"model_components/dynamical_types/#","page":"Dynamical Problem Types","title":"Dynamical Problem Types","text":"beginalign\r\nDepot1   = -Ka1*Depot1\r\nDepot2   = -Ka2*Depot2\r\nCentral  =  Ka1*Depot1 + Ka2*Depot2 - (CLV)*Central\r\nendalign","category":"page"},{"location":"model_components/dynamical_types/#DEProblem-1","page":"Dynamical Problem Types","title":"DEProblem","text":"","category":"section"},{"location":"model_components/dynamical_types/#","page":"Dynamical Problem Types","title":"Dynamical Problem Types","text":"DEProblems are types from DifferentialEquations.jl which are used to specify differential equations to be solved numerically via the solvers of the package. In the @model interface, the DEProblem is set to be an ODEProblem defining an ODE. In the function-based interface, any DEProblem can be used, which includes:","category":"page"},{"location":"model_components/dynamical_types/#","page":"Dynamical Problem Types","title":"Dynamical Problem Types","text":"Discrete equations (function maps, discrete stochastic (Gillespie/Markov) simulations)\nOrdinary differential equations (ODEs)\nSplit and Partitioned ODEs (Symplectic integrators, IMEX Methods)\nStochastic ordinary differential equations (SODEs or SDEs)\nRandom differential equations (RODEs or RDEs)\nDifferential algebraic equations (DAEs)\nDelay differential equations (DDEs)\nMixed discrete and continuous equations (Hybrid Equations, Jump Diffusions)","category":"page"},{"location":"model_components/dynamical_types/#","page":"Dynamical Problem Types","title":"Dynamical Problem Types","text":"The problem type that is given can use sentinel values for the initial condition, timespan, and parameters which will be overridden by PuMaS during the simulation chain.","category":"page"},{"location":"analysis/diagnostics/#Simulation-and-Estimation-Diagnostics-1","page":"Simulation and Estimation Diagnostics","title":"Simulation and Estimation Diagnostics","text":"","category":"section"},{"location":"analysis/diagnostics/#The-predict-Function-1","page":"Simulation and Estimation Diagnostics","title":"The predict Function","text":"","category":"section"},{"location":"analysis/diagnostics/#Individual-Diagnostic-Functions-1","page":"Simulation and Estimation Diagnostics","title":"Individual Diagnostic Functions","text":"","category":"section"},{"location":"analysis/diagnostics/#Population-Residuals-1","page":"Simulation and Estimation Diagnostics","title":"Population Residuals","text":"","category":"section"},{"location":"analysis/diagnostics/#","page":"Simulation and Estimation Diagnostics","title":"Simulation and Estimation Diagnostics","text":"npde\nwres\ncwres","category":"page"},{"location":"analysis/diagnostics/#Individual-Residuals-1","page":"Simulation and Estimation Diagnostics","title":"Individual Residuals","text":"","category":"section"},{"location":"analysis/diagnostics/#","page":"Simulation and Estimation Diagnostics","title":"Simulation and Estimation Diagnostics","text":"iwres\nicwres\nicwresi\ninpde","category":"page"},{"location":"analysis/diagnostics/#Model-Metrics-1","page":"Simulation and Estimation Diagnostics","title":"Model Metrics","text":"","category":"section"},{"location":"analysis/diagnostics/#","page":"Simulation and Estimation Diagnostics","title":"Simulation and Estimation Diagnostics","text":"-2LL\nAIC\nBIC","category":"page"},{"location":"analysis/diagnostics/#Random-Effects-1","page":"Simulation and Estimation Diagnostics","title":"Random Effects","text":"","category":"section"},{"location":"analysis/diagnostics/#","page":"Simulation and Estimation Diagnostics","title":"Simulation and Estimation Diagnostics","text":"eta_bar (normality test)\neta_shrinkage\neps_shrinkage\ncondition_number","category":"page"},{"location":"analysis/sensitivity/#Local-and-Global-Sensitivity-Analysis-1","page":"Local and Global Sensitivity Analysis","title":"Local and Global Sensitivity Analysis","text":"","category":"section"},{"location":"analysis/sensitivity/#Discrete-Local-Sensitivity-Analysis-via-AD-(DSAAD)-1","page":"Local and Global Sensitivity Analysis","title":"Discrete Local Sensitivity Analysis via AD (DSAAD)","text":"","category":"section"},{"location":"analysis/sensitivity/#Global-Sensitivity-Analysis-1","page":"Local and Global Sensitivity Analysis","title":"Global Sensitivity Analysis","text":"","category":"section"}]
}
